---
sidebar_position: 4
---

# Navigation with Nav2

Master Nav2, the next-generation navigation framework for ROS 2, enabling autonomous robot navigation in complex environments.

## Learning Objectives

By the end of this chapter, you will be able to:

- Understand Nav2 architecture and components
- Configure costmaps for obstacle avoidance
- Use behavior trees for navigation logic
- Implement waypoint following and coverage
- Tune navigation parameters for your robot
- Deploy Nav2 to real robots

---

## What is Nav2?

**Nav2 (Navigation2)** is the ROS 2 navigation framework providing:

- **Global Planning**: Find optimal paths (A*, Dijkstra, Theta*)
- **Local Planning**: Real-time obstacle avoidance (DWB, TEB, MPPI)
- **Recovery Behaviors**: Handle stuck situations
- **Behavior Trees**: Flexible navigation logic
- **Costmap2D**: Layered environment representation
- **Lifecycle Management**: Robust state management

### Nav2 vs Move_Base (ROS 1)

| Feature | Move_Base (ROS 1) | **Nav2 (ROS 2)** |
|---------|-------------------|------------------|
| **Architecture** | Monolithic | **Modular servers** |
| **Logic** | Fixed recovery | **Behavior trees** |
| **Planners** | Limited | **Pluggable** |
| **State Machine** | Basic | **Lifecycle nodes** |
| **Performance** | Moderate | **Optimized** |

---

## Nav2 Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Navigator ‚îÇ  (Behavior Tree Executor)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚îÇ
      ‚îú‚îÄ‚îÄ> ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ    ‚îÇ Controller     ‚îÇ  (Local planner)
      ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚îÇ
      ‚îú‚îÄ‚îÄ> ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ    ‚îÇ Planner Server ‚îÇ  (Global planner)
      ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚îÇ
      ‚îú‚îÄ‚îÄ> ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ    ‚îÇ Recovery Server‚îÇ  (Spin, backup, wait)
      ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
      ‚îÇ
      ‚îî‚îÄ‚îÄ> ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇ Behavior Tree  ‚îÇ  (Navigation logic)
           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
           ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
           ‚îÇ   Costmap2D   ‚îÇ
           ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  ‚îÇ
      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
      ‚îÇ           ‚îÇ           ‚îÇ
   Static      Obstacle    Inflation
    Layer       Layer       Layer
```

---

## Installation

```bash
# Install Nav2
sudo apt install ros-humble-navigation2 ros-humble-nav2-bringup -y

# Install SLAM Toolbox (for mapping)
sudo apt install ros-humble-slam-toolbox -y

# Install Visualization tools
sudo apt install ros-humble-rviz2 ros-humble-rqt* -y
```

---

## Costmap Configuration

Costmaps represent the environment with obstacles and free space.

### Costmap Layers

1. **Static Layer**: From map (SLAM/pre-made)
2. **Obstacle Layer**: From sensors (LiDAR, depth)
3. **Inflation Layer**: Safety buffer around obstacles
4. **Voxel Layer**: 3D obstacles (optional)

### Configuration File

```yaml title="nav2_params.yaml"
global_costmap:
  global_costmap:
    ros__parameters:
      update_frequency: 1.0
      publish_frequency: 1.0
      global_frame: map
      robot_base_frame: base_link
      use_sim_time: false

      robot_radius: 0.22  # Circular robot
      resolution: 0.05
      track_unknown_space: true

      plugins: ["static_layer", "obstacle_layer", "inflation_layer"]

      static_layer:
        plugin: "nav2_costmap_2d::StaticLayer"
        map_subscribe_transient_local: true

      obstacle_layer:
        plugin: "nav2_costmap_2d::ObstacleLayer"
        enabled: true
        observation_sources: scan
        scan:
          topic: /scan
          max_obstacle_height: 2.0
          clearing: true
          marking: true
          data_type: "LaserScan"
          raytrace_max_range: 10.0
          raytrace_min_range: 0.0
          obstacle_max_range: 9.5
          obstacle_min_range: 0.0

      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        cost_scaling_factor: 3.0
        inflation_radius: 0.55

local_costmap:
  local_costmap:
    ros__parameters:
      update_frequency: 5.0
      publish_frequency: 2.0
      global_frame: odom
      robot_base_frame: base_link
      use_sim_time: false

      rolling_window: true
      width: 3
      height: 3
      resolution: 0.05
      robot_radius: 0.22

      plugins: ["voxel_layer", "inflation_layer"]

      voxel_layer:
        plugin: "nav2_costmap_2d::VoxelLayer"
        enabled: true
        publish_voxel_map: true
        origin_z: 0.0
        z_resolution: 0.05
        z_voxels: 16
        max_obstacle_height: 2.0
        mark_threshold: 0
        observation_sources: scan
        scan:
          topic: /scan
          max_obstacle_height: 2.0
          clearing: true
          marking: true
          data_type: "LaserScan"

      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        cost_scaling_factor: 3.0
        inflation_radius: 0.55

planner_server:
  ros__parameters:
    expected_planner_frequency: 20.0
    use_sim_time: false
    planner_plugins: ["GridBased"]
    GridBased:
      plugin: "nav2_navfn_planner/NavfnPlanner"
      tolerance: 0.5
      use_astar: false
      allow_unknown: true

controller_server:
  ros__parameters:
    use_sim_time: false
    controller_frequency: 20.0
    min_x_velocity_threshold: 0.001
    min_y_velocity_threshold: 0.5
    min_theta_velocity_threshold: 0.001
    failure_tolerance: 0.3
    progress_checker_plugin: "progress_checker"
    goal_checker_plugins: ["general_goal_checker"]
    controller_plugins: ["FollowPath"]

    progress_checker:
      plugin: "nav2_controller::SimpleProgressChecker"
      required_movement_radius: 0.5
      movement_time_allowance: 10.0

    general_goal_checker:
      stateful: true
      plugin: "nav2_controller::SimpleGoalChecker"
      xy_goal_tolerance: 0.25
      yaw_goal_tolerance: 0.25

    FollowPath:
      plugin: "dwb_core::DWBLocalPlanner"
      debug_trajectory_details: true
      min_vel_x: 0.0
      min_vel_y: 0.0
      max_vel_x: 0.26
      max_vel_y: 0.0
      max_vel_theta: 1.0
      min_speed_xy: 0.0
      max_speed_xy: 0.26
      min_speed_theta: 0.0
      acc_lim_x: 2.5
      acc_lim_y: 0.0
      acc_lim_theta: 3.2
      decel_lim_x: -2.5
      decel_lim_y: 0.0
      decel_lim_theta: -3.2
      vx_samples: 20
      vy_samples: 5
      vth_samples: 20
      sim_time: 1.7
      linear_granularity: 0.05
      angular_granularity: 0.025
      transform_tolerance: 0.2
      xy_goal_tolerance: 0.25
      trans_stopped_velocity: 0.25
      short_circuit_trajectory_evaluation: true
      stateful: true
      critics: ["RotateToGoal", "Oscillation", "BaseObstacle", "GoalAlign", "PathAlign", "PathDist", "GoalDist"]
      BaseObstacle.scale: 0.02
      PathAlign.scale: 32.0
      PathAlign.forward_point_distance: 0.1
      GoalAlign.scale: 24.0
      GoalAlign.forward_point_distance: 0.1
      PathDist.scale: 32.0
      GoalDist.scale: 24.0
      RotateToGoal.scale: 32.0
      RotateToGoal.slowing_factor: 5.0
      RotateToGoal.lookahead_time: -1.0
```

---

## Basic Navigation

### Launch Nav2

```bash
# Terminal 1: Launch robot (with sensors)
ros2 launch my_robot robot.launch.py

# Terminal 2: Launch SLAM (to create map)
ros2 launch slam_toolbox online_async_launch.py

# Terminal 3: Launch Nav2
ros2 launch nav2_bringup navigation_launch.py \
  params_file:=/path/to/nav2_params.yaml
```

### Send Navigation Goal

```python title="navigate_to_pose.py"
#!/usr/bin/env python3
"""
Send navigation goal to Nav2
"""

import rclpy
from rclpy.node import Node
from geometry_msgs.msg import PoseStamped
from nav2_msgs.action import NavigateToPose
from rclpy.action import ActionClient


class Navigator(Node):
    """Navigate to a goal pose."""

    def __init__(self):
        super().__init__('navigator')

        # Action client
        self._action_client = ActionClient(
            self,
            NavigateToPose,
            'navigate_to_pose'
        )

        self.get_logger().info('Navigator ready')

    def send_goal(self, x: float, y: float, yaw: float):
        """Send navigation goal."""
        goal_msg = NavigateToPose.Goal()

        # Create pose
        goal_msg.pose.header.frame_id = 'map'
        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()
        goal_msg.pose.pose.position.x = x
        goal_msg.pose.pose.position.y = y
        goal_msg.pose.pose.position.z = 0.0

        # Convert yaw to quaternion
        import math
        goal_msg.pose.pose.orientation.z = math.sin(yaw / 2)
        goal_msg.pose.pose.orientation.w = math.cos(yaw / 2)

        self.get_logger().info(f'Sending goal: ({x}, {y}, {yaw})')

        # Wait for server
        self._action_client.wait_for_server()

        # Send goal
        self._send_goal_future = self._action_client.send_goal_async(
            goal_msg,
            feedback_callback=self.feedback_callback
        )

        self._send_goal_future.add_done_callback(self.goal_response_callback)

    def goal_response_callback(self, future):
        """Handle goal acceptance."""
        goal_handle = future.result()

        if not goal_handle.accepted:
            self.get_logger().info('Goal rejected')
            return

        self.get_logger().info('Goal accepted')

        self._get_result_future = goal_handle.get_result_async()
        self._get_result_future.add_done_callback(self.get_result_callback)

    def feedback_callback(self, feedback_msg):
        """Log navigation progress."""
        feedback = feedback_msg.feedback
        distance_remaining = feedback.distance_remaining

        self.get_logger().info(f'Distance remaining: {distance_remaining:.2f}m')

    def get_result_callback(self, future):
        """Handle navigation result."""
        result = future.result().result
        status = future.result().status

        if status == 4:  # SUCCEEDED
            self.get_logger().info('Goal reached!')
        elif status == 5:  # ABORTED
            self.get_logger().error('Goal aborted!')
        elif status == 6:  # CANCELED
            self.get_logger().warn('Goal canceled')


def main(args=None):
    rclpy.init(args=args)

    navigator = Navigator()

    # Send goal: x=2.0, y=1.0, yaw=0 (facing right)
    navigator.send_goal(2.0, 1.0, 0.0)

    rclpy.spin(navigator)

    navigator.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

---

## Waypoint Following

Navigate through multiple waypoints sequentially.

```python title="waypoint_follower.py"
#!/usr/bin/env python3
"""
Follow a sequence of waypoints
"""

import rclpy
from rclpy.node import Node
from nav2_msgs.action import FollowWaypoints
from geometry_msgs.msg import PoseStamped
from rclpy.action import ActionClient
import math


class WaypointFollower(Node):
    """Follow waypoints using Nav2."""

    def __init__(self):
        super().__init__('waypoint_follower')

        self._action_client = ActionClient(
            self,
            FollowWaypoints,
            'follow_waypoints'
        )

        self.get_logger().info('Waypoint Follower ready')

    def follow_waypoints(self, waypoints: list):
        """
        Follow list of waypoints.

        Args:
            waypoints: List of (x, y, yaw) tuples
        """
        goal_msg = FollowWaypoints.Goal()

        # Create poses
        for x, y, yaw in waypoints:
            pose = PoseStamped()
            pose.header.frame_id = 'map'
            pose.header.stamp = self.get_clock().now().to_msg()

            pose.pose.position.x = x
            pose.pose.position.y = y
            pose.pose.position.z = 0.0

            pose.pose.orientation.z = math.sin(yaw / 2)
            pose.pose.orientation.w = math.cos(yaw / 2)

            goal_msg.poses.append(pose)

        self.get_logger().info(f'Following {len(waypoints)} waypoints')

        # Wait and send
        self._action_client.wait_for_server()
        self._send_goal_future = self._action_client.send_goal_async(
            goal_msg,
            feedback_callback=self.feedback_callback
        )
        self._send_goal_future.add_done_callback(self.goal_response_callback)

    def goal_response_callback(self, future):
        """Handle goal acceptance."""
        goal_handle = future.result()

        if not goal_handle.accepted:
            self.get_logger().info('Waypoints rejected')
            return

        self.get_logger().info('Waypoints accepted')

        self._get_result_future = goal_handle.get_result_async()
        self._get_result_future.add_done_callback(self.get_result_callback)

    def feedback_callback(self, feedback_msg):
        """Log waypoint progress."""
        current_waypoint = feedback_msg.feedback.current_waypoint

        self.get_logger().info(f'Current waypoint: {current_waypoint + 1}')

    def get_result_callback(self, future):
        """Handle result."""
        status = future.result().status

        if status == 4:
            self.get_logger().info('All waypoints reached!')
        else:
            self.get_logger().error(f'Waypoint following failed: {status}')


def main(args=None):
    rclpy.init(args=args)

    follower = WaypointFollower()

    # Define waypoints (x, y, yaw)
    waypoints = [
        (1.0, 0.0, 0.0),
        (1.0, 1.0, 1.57),
        (0.0, 1.0, 3.14),
        (0.0, 0.0, 0.0),
    ]

    follower.follow_waypoints(waypoints)

    rclpy.spin(follower)

    follower.destroy_node()
    rclpy.shutdown()


if __name__ == '__main__':
    main()
```

---

## Behavior Trees

Nav2 uses behavior trees for flexible navigation logic.

### Default Behavior Tree

```xml title="navigate_w_replanning_and_recovery.xml"
<root main_tree_to_execute="MainTree">
  <BehaviorTree ID="MainTree">
    <RecoveryNode number_of_retries="6" name="NavigateRecovery">
      <PipelineSequence name="NavigateWithReplanning">
        <RateController hz="1.0">
          <RecoveryNode number_of_retries="1" name="ComputePathToPose">
            <ComputePathToPose goal="{goal}" path="{path}" planner_id="GridBased"/>
            <ClearEntireCostmap name="ClearGlobalCostmap-Context" service_name="global_costmap/clear_entirely_global_costmap"/>
          </RecoveryNode>
        </RateController>
        <RecoveryNode number_of_retries="1" name="FollowPath">
          <FollowPath path="{path}" controller_id="FollowPath"/>
          <ClearEntireCostmap name="ClearLocalCostmap-Context" service_name="local_costmap/clear_entirely_local_costmap"/>
        </RecoveryNode>
      </PipelineSequence>
      <ReactiveFallback name="RecoveryFallback">
        <GoalUpdated/>
        <SequenceStar name="RecoveryActions">
          <ClearEntireCostmap name="ClearLocalCostmap-Subtree" service_name="local_costmap/clear_entirely_local_costmap"/>
          <ClearEntireCostmap name="ClearGlobalCostmap-Subtree" service_name="global_costmap/clear_entirely_global_costmap"/>
          <Spin spin_dist="1.57"/>
          <Wait wait_duration="5"/>
          <BackUp backup_dist="0.15" backup_speed="0.025"/>
        </SequenceStar>
      </ReactiveFallback>
    </RecoveryNode>
  </BehaviorTree>
</root>
```

---

## Parameter Tuning

### Critical Parameters

| Parameter | Effect | Tuning |
|-----------|--------|--------|
| **robot_radius** | Safety buffer | Increase if colliding |
| **inflation_radius** | Obstacle buffer | Balance safety vs path efficiency |
| **max_vel_x** | Max speed | Lower for indoor, higher for outdoor |
| **acc_lim_x** | Acceleration | Match robot capabilities |
| **xy_goal_tolerance** | Goal precision | Tighter for docking |
| **sim_time** | Look-ahead | Longer for high speed |

### Tuning Process

1. **Conservative Start**: Safe, slow parameters
2. **Test Environment**: Simple scenario first
3. **Incremental Changes**: One parameter at a time
4. **Record Results**: Log success/failure rates
5. **Iterate**: Refine based on data

---

## Monitoring and Debugging

### Visualize in RViz2

```bash
ros2 run rviz2 rviz2
```

**Add Displays**:
- **Map**: Global costmap
- **Path**: Planned path
- **Local Costmap**: Obstacle avoidance
- **Robot Model**: Robot position
- **LaserScan**: Sensor data

### Check Node Status

```bash
# List Nav2 nodes
ros2 node list

# Check lifecycle state
ros2 lifecycle get /controller_server
ros2 lifecycle get /planner_server

# View topics
ros2 topic list
ros2 topic echo /local_costmap/costmap
```

---

## Best Practices

1. **Map Quality**: Ensure clean, up-to-date maps
2. **Sensor Coverage**: 360¬∞ LiDAR or multi-camera setup
3. **Localization**: Use AMCL or Visual SLAM
4. **Recovery Behaviors**: Enable spinning and backing up
5. **Testing**: Simulate before deploying to real robot

---

## Self-Assessment

### Questions

1. **What's the difference between global and local costmaps?**
   <details>
   <summary>Answer</summary>
   Global costmap uses the full map for long-range planning. Local costmap is a rolling window around the robot for real-time obstacle avoidance.
   </details>

2. **What is a behavior tree in Nav2?**
   <details>
   <summary>Answer</summary>
   A behavior tree defines navigation logic including planning, control, and recovery actions in a modular, hierarchical structure.
   </details>

3. **How do you tune Nav2 for a faster robot?**
   <details>
   <summary>Answer</summary>
   Increase max velocities, accelerations, and sim_time. Reduce safety margins (inflation_radius) if environment permits.
   </details>

### Exercises

1. **Configure Nav2**: Set up Nav2 for your robot with custom costmap parameters

2. **Navigate to Goal**: Send a navigation goal and reach it successfully

3. **Waypoint Following**: Define a square path with 4 waypoints and complete it

4. **Parameter Tuning**: Optimize max speed and acceleration for smooth navigation

5. **Recovery Behaviors**: Intentionally block the robot and observe recovery actions

---

## Next Steps

Congratulations on completing Module 3! You now master NVIDIA Isaac for AI robotics. Proceed to:

üëâ [Module 4: Vision-Language-Action (VLA)](../module-4/01-vla-intro.md) to learn AI-powered robot control

---

## Additional Resources

- [Nav2 Documentation](https://navigation.ros.org/)
- [Nav2 Tuning Guide](https://navigation.ros.org/tuning/index.html)
- [Behavior Trees](https://www.behaviortree.dev/)
- [Nav2 Configuration Guide](https://navigation.ros.org/configuration/index.html)

---

**Key Takeaway**: Nav2 provides a robust, modular navigation framework with behavior trees, pluggable planners, and recovery behaviors. Mastering Nav2 enables autonomous navigation in complex, dynamic environments.
